# WebSid (Raspberry Pi4 edition)

This sub-project uses the base WebSid emulator as a natively compiled program on a 
Raspberry Pi 4 (RPi4). But the purpose is not to play sid-files via the emulation 
but to instead control a real SID chip (see https://www.youtube.com/watch?v=pLZrO581B3Q ).

The SID chip is connected to the Raspberry based on Gianluca Ghettini's "SidBerry" design 
(see https://www.gianlucaghettini.net/sidberry-raspberrypi-sid-player/ ). The audio 
output is generated by the real SID chip and WebSid is just used to emulate all the 
other parts of a C64 that are needed to feed the right signals to the SID chip.


My "SidBerry" device does not support read access to the SID chip (the SID chip is therefore 
hardwired to input mode). This flaw does not affect many songs (i.e. songs that read 
SID registers) and the respective output of the emulator should be good enough for 
those songs that use it. Also it would be impossible on a RPi4 to feed the output of 
the SID into the emulation since the emulator would then need to match its emulation 
speed to the exact speed of the SID.


Other known limitations: The current impl does not support playback of .mus files 
nor the use of ROM files (though those features could be easily added). Also multi-
SID files are not supported by the current HW configuration and related functionality 
has therefore not been tested.

Timing flaws: The SID chip on the enhanced "SidBerry board" is clocked by a 1MHz 
crystal, i.e. it is NOT the correct clock rate neither for PAL nor for NTSC. For PAL 
use, the SID will be slightly too fast and for NTSC use, slightly too slow, affecting 
the frequencies of the SID produced waveforms accordingly. Timing on the Rapberry side 
is flawed in two ways: 1) non-maskable scheduler interrupts may delay the playback logic 
for short periods of time thus making it impossible to always achieve the correct 
"micro second precision" timing. 2) The CPU's "micro second counter" is driven by the 
CPU's original clock rate (700MHz-1500Mhz) and may be adversely affected by integer 
division "rounding" issues - and dynamically changing clock speeds should therefore 
better be avoided (todo: determine optimal clockrate for playback thread). Respective 
clock mismatches should not be noticable in most regular songs but they probably add 
periodic disturbances to songs that rely on high-speed SID updates - like certain 
digi-sample players do.

Performance considerations: Measurements using the regular emulator on a normally 
scheduled Linux process suggest that it is fast enough to produce its output in realtime 
on one Raspberry Pi 4 CPU core: producing 20ms of output took between 7-8ms for a simple 
PSID (Lightforce.sid) and 3-12ms for an RSID (LMan - Vortex.sid). This performance still 
leaves some margin for error but it is obviously not enough leeway to integrate additional 
1MHz synchonisation directly into the emulation logic. (The measurements are an indication 
that the program might be successfully adapted to also run on slower Raspberry Pi 3 
devices - in case anyone what's to try that. If necessary, WebSid's SID chip emulation 
could here still be disabled as a performance optimization. To be run on other 
Raspberry models, the "getBaseAddress" function in rpi4_utils.cpp would in any case need 
to be adapted.)

The current impl uses two CPU cores to make playback as "precise" as possible. The actual 
playback is performed by a relatively "dumb" playback thread that runs on CPU core #3. 
By specifically reserving that core #3 to "exclusive" use by the playback thread, 
interrupts are kept to a minimum. The playback thread just follows a sequential playback 
script that tells it when to write some SID register. Playback scripts are supplied by a 
second thread (the main thread) which runs the WebSid emulator and which is not very 
timing critical (see performance considerations above).


todo: The idea is to eventually extend the "SidBerry" device such that the SID's
output can be directly captured on the Raspberry via some A/D converter.
todo: The simulated WebSid output is still available and it might be simultaneously 
written to some file to ease comparisons with the real SID signal.



## Howto use

1) use a RPi4 with the normal Raspberry OS; impl is currently NOT adapted 
   to older models (rpi4_utils.cpp must first be adapted for other models)
2) preferably the RPi4 should boot into plain shell mode with as little extra 
   tasks (e.g. no desktop) running as possible (at least that's how I tested)
3) the following entries should be added to /boot/cmdline.txt (the RPi4 must
   be rebooted after that change): isolcpus=3 rcu_nocbs=3 rcu_nocb_poll=3 nohz_full=3 
   (the config isolates CPU core #3 as far as possible from normal use by the 
   Linux scheduler - you might want to again remove those entries before you use
   your RPi4 for something else). This ensures that the timing of the playpack
   thread is disturbed as little as possible. (Please let me know if you have a 
   suitable kernel hack that makes the scheduler leave the playback thread alone
   completely :-) that would fix the remaining glitches in timing critical songs..)
4) start using sudo, e.g. "sudo ./websid somesong.sid"
5) playback can be interrupted by pressing ctrl-C
   
   
## Depencencies

The player comes bundled with a stripped down version of "Wiring Pi". And for use on 
the RPi4B no additional libs are needed.

In principle a regular version of "Wiring Pi" (see https://github.com/WiringPi/WiringPi) 
could be used just as well (which might be useful when migrating the code to a 
different Raspberry model). see Makefile for respective information.


## License
Terms of Use: This software is licensed under a CC BY-NC-SA 
(http://creativecommons.org/licenses/by-nc-sa/4.0/)
