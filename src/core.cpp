/*
* This is the interface for using the actual emulator.
* 
* This updated implementation uses a cycle-by-cycle emulation of the different
* C64 components (VIC, SID, CIA, CPU).
*
* PSID files are wrapped with respective driver code so that the regular
* RSID emulation can be used.
*
* Note: It is still a somewhat high level emulation, i.e. unlike very precise
* emulators it does NOT emulate different phases of a system clock cycle, nor
* respective detailed internal workings of all the various components (e.g. CPU).
* 
* WebSid (c) 2019 Jürgen Wothke
* version 0.94
*
* Terms of Use: This software is licensed under a CC BY-NC-SA
* (http://creativecommons.org/licenses/by-nc-sa/4.0/).
*/

#include <string.h>
#include <stdio.h>
#include <math.h>

#include "core.h"

extern "C" {
#include "memory.h"
#include "cpu.h"
#include "vic.h"
#include "cia.h"
#include "hacks.h"
}
#include "sid.h"

#include <emscripten.h>

// if PSID 'init' subroutine takes longer than 4 secs then something
// is wrong (mb in endless loop) test case: PSID "ALiH" type players
// (e.g. Simulcra.sid) use more than 2M cycles in their INIT

#define CYCLELIMIT 4000000


// the clocks used in the emulation do not usually match the used audio
// output sample rate and fractional overflows are handled here:
static double _sample_cycles;

static void resetDefaults(uint32_t sample_rate, uint8_t is_rsid, 
							uint8_t ntsc_mode, uint8_t compatibility) {
	cpuInit();
	
    memResetIO();

	ciaReset(is_rsid);
	vicReset(is_rsid, ntsc_mode);
	
	SID::resetAll(sample_rate, compatibility, 1);
	
	_sample_cycles= 0;
}

#ifdef TEST
// ------------------ to run Wolfgang Lorenz's test-suite ---------------------

extern uint8_t test_running;

void testInit(void)
{
	memRestoreSnapshot();
	resetDefaults(44100, 1, 0, 1);
}

void Core::rsidRunTest() {
	testInit();
	
	// use same sequence as in runEmulation (just without generating sample output)
	while(test_running) {
		// VIC always uses the 1st phase of each ϕ2 clock cycle (for bus access) so it
		// should be clocked first (after all it is where the system clock comes from..)
		vicClock();		
		ciaClock();
		SID::clockAll();
		
		cpuClock();	// invalid "main" should just keep burning cycles one-by-one
		uint8_t valid_pc= cpuIsValidPcPSID();
		
		if (!valid_pc ) { 
			test_running= 0;
		}	
		cpuClockSystem();
	}
}
#endif


void copyMonoSignal(int16_t *synth_buffer, uint16_t samples_per_call) {
	for (int i = 0; i<samples_per_call; i++) {
		synth_buffer[(i<<1) + 1]= synth_buffer[i<<1]; // single-SID songs are mono
	}
}

// For some reason "inline" does not seem to reliably work in the 
// EMSCRIPTEN context and the below "defines" serve the same purpose 
// (avoid additional subroutine nesting just in case).

// clocking used for "normal" songs". note: for a slow garbage song 
// like Baroque_Music_64_BASIC the isAudible() check brings down 
// the "silence detection" from 33 sec to 19 secs

#define CLOCK_OPTIMIZED() \
	vicClock(); \
	ciaClock(); \
	if (SID::isAudible()) { SID::clockAll(); }; \
	cpuClock(); \
	cpuClockSystem()

#define SYNTH_NORMAL(synth_buffer, synth_trace_bufs, scale, i) \
	if (SID::isAudible()) { \
		SID::synthSample(synth_buffer, synth_trace_bufs, &scale, i); \
	} else { \
		synth_buffer[(i<<1)]= 0; \
	}

#define CLOCK_NORMAL() \
	vicClock(); \
	ciaClock(); \
	SID::clockAll(); \
	cpuClock();	 \
	cpuClockSystem()

	
void runEmulation(uint8_t is_single_sid, int16_t *synth_buffer, 
					int16_t **synth_trace_bufs, uint16_t samples_per_call) {
						
	double n= SID::getCyclesPerSample();

	// trivia: The system clock rate (and others) is generated by the VIC 
	// and feed to the CPU's ϕ1 pin. The CPU pin that then outputs the system 
	// clock rate for use by other components is called Phase 2 or Phi2 (ϕ2).
	
	// VIC always uses the 1st phase of each ϕ2 clock cycle (for bus access) 
	// so it should be clocked first.

	// performance info: JavaScript performance.now() measurements with a 8SID 
	// song suggest that only a small fraction of the overall runtime is spent
	// in the SID::synthSample() and most of the time is spent in the earlier
	// clock-by-clock emulation of the system components; 2 (5) vs 12 (21)
	
	double scale= SID::getScale();	// avoid recalc within loop
	
	if (is_single_sid) {
		for (int i = 0; i<samples_per_call; i++) {
			while(_sample_cycles < n) {
				CLOCK_OPTIMIZED();
				_sample_cycles++;
			}
			_sample_cycles-= n;	// keep overflow
			
			SYNTH_NORMAL(synth_buffer, synth_trace_bufs, scale, i);
		}
		copyMonoSignal(synth_buffer, samples_per_call);

	} else {
//		EM_ASM_({ window['start']= performance.now();});		
		for (int i = 0; i<samples_per_call; i++) {
			while(_sample_cycles < n) {
				CLOCK_NORMAL();
				_sample_cycles++;
			}
			_sample_cycles-= n;	// keep overflow
			
			// optimization: use no filter for trace buffers & no digis 
			// (my slow PC is really at the limit here as it is)
			SID::synthSampleStripped(synth_buffer, synth_trace_bufs, &scale, i);
		}
/*
		EM_ASM_({ 
			window['start']= performance.now()-window['start'];
			if (typeof window['count'] == 'undefined') { window['count']= 0; window['sum']= 0; }
			
			window['sum']+= window['start'];
			window['count']+= 1;
			
			if (window['count'] == 100) {
				console.log("t: "+window['sum']/100);
				 window['count']= 0; 
				 window['sum']= 0;
			}			
		});
*/
	}
}

uint8_t Core::runOneFrame(uint8_t is_single_sid, uint8_t speed, int16_t *synth_buffer, 
							int16_t **synth_trace_bufs, uint16_t samples_per_call) {
								
	SID::resetGlobalStatistics();

	ciaUpdateTOD(speed); // hack: TOD is rarely used so there is no point to do it more precisely
	
	runEmulation(is_single_sid, synth_buffer, synth_trace_bufs, samples_per_call);
	
	return 0;
}

void Core::loadSongBinary(uint8_t *src, uint16_t dest_addr, uint16_t len, uint8_t basic_mode) {
	memCopyToRAM(src, dest_addr, len);

	if (basic_mode) {
		memSetupBASIC(len);
	}
	
	memSaveSnapshot();
}

uint8_t runSubroutineTilEnd() {
	while (cpuIsValidPcPSID()) {
		cpuClock();
		
		if (cpuCycles() >= CYCLELIMIT ) {
			EM_ASM_({ console.log('ERROR: PSID INIT hangs');});	// less mem than inclusion of fprintf
			return 0;
		}
		// this is probably overkill for PSID crap..
		vicClock(); 
		ciaClock(); 
		SID::clockAll();
		cpuClockSystem();
	}
	return 1;
}

void Core::callKernalROMReset() {
	// regular "kernal ROM" based RESET provides most of the environment
	// needed for BASIC programs. precondition: RSID mode; standard 
	// kernal & basic ROMs must be available
		
	resetDefaults(44100, 1, 0, 1);	// dummy settings good enough for RESET

	// note: it might be a good idea to strip down the standard ROM impl 
	// which unnecessarily wastes many cycles for useless RAM tests, etc
	uint16_t rom_routine= 0xFCE2;	
	cpuReset(rom_routine, 0);
	
	runSubroutineTilEnd();
	
//	EM_ASM_({ console.log('C64 RESET completed');});
	
	// note: the used ROM might not match the song's settings (e.g. PAL/NTSC)
	// and the respective memory snapshot that is taken on the above base may 
	// be flawed. But that doesn't matter since timing specific settings are 
	// always reset before playing a sub-tune.
}

uint8_t runInitPSID(uint16_t *init_addr, uint8_t actual_subsong) {
	// run the the PSID's "INIT" subroutine separately so that the "bank"
	// setting can be handled here on the C/C++ side
	
	cpuReset((*init_addr), actual_subsong);	// set starting point for emulation	
	
	cpuIrqFlagPSID(1);	// block IRQ during INIT
	
	if (!runSubroutineTilEnd()) return 0;
	
	cpuIrqFlagPSID(0);

	return 1;
}

void Core::startupSong(uint32_t sample_rate, uint8_t is_rsid, uint8_t is_timer_driven_psid, 
						uint8_t ntsc_mode, uint8_t compatibility, uint8_t basic_mode, 
						uint16_t *init_addr, uint16_t load_end_addr, 
						uint16_t play_addr, uint8_t actual_subsong) {
	
	resetDefaults(sample_rate, is_rsid, ntsc_mode, compatibility);
	
	memRestoreSnapshot();	// previous sub-tune run may have corrupted the RAM

	hackIfNeeded(init_addr);
	
	memSetDefaultBanksPSID(is_rsid, (*init_addr), load_end_addr);	// PSID crap
		
	if (!is_rsid) {
		
		if (!runInitPSID(init_addr, actual_subsong)) return;
		
		uint16_t main= memPsidMain(play_addr);		
		cpuResetToPSID(main);	// just install an endless loop for main
			
		ciaSetDefaultsPSID(is_timer_driven_psid);
		vicSetDefaultsPSID(is_timer_driven_psid);
		
	} else {
		memRsidInit(init_addr, actual_subsong, basic_mode);
		cpuReset((*init_addr), actual_subsong);
	}
}

